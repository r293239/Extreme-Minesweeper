<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üí£ 3D Minesweeper Pro Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
        }

        .game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            pointer-events: auto;
        }

        .hud-section {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            pointer-events: auto;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-primary { background: linear-gradient(45deg, #007bff, #0056b3); }
        .btn-success { background: linear-gradient(45deg, #28a745, #1e7e34); }
        .btn-danger { background: linear-gradient(45deg, #dc3545, #a71e2a); }
        .btn-warning { background: linear-gradient(45deg, #ffc107, #d39e00); }
        .btn-secondary { background: linear-gradient(45deg, #6c757d, #495057); }

        .difficulty-selector {
            position: absolute;
            top: 100px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }

        .difficulty-btn {
            padding: 8px 16px;
            font-size: 12px;
            min-width: 120px;
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, #28a745, #1e7e34);
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.4);
        }

        .game-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            font-size: 12px;
            color: #ccc;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .camera-controls {
            position: absolute;
            right: 20px;
            top: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .camera-btn {
            padding: 8px 12px;
            font-size: 12px;
            min-width: 100px;
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            cursor: crosshair;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .game-over-content {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .game-over-title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .instructions {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(15px);
            max-width: 300px;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: opacity 0.3s ease;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #ffc107;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .instructions ul {
            list-style: none;
            padding: 0;
        }

        .instructions li {
            margin: 5px 0;
            padding-left: 15px;
            position: relative;
        }

        .instructions li::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #007bff;
        }

        .performance-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 10px;
            color: #888;
            pointer-events: auto;
            font-family: 'Courier New', monospace;
        }

        .settings-panel {
            position: absolute;
            top: 250px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto;
            max-width: 200px;
        }

        .settings-panel h4 {
            margin-bottom: 10px;
            color: #ffc107;
            font-size: 14px;
        }

        .setting-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .setting-item input[type="range"] {
            flex: 1;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .game-hud {
                flex-direction: column;
                align-items: stretch;
            }
            
            .instructions, .settings-panel {
                display: none;
            }
            
            .camera-controls {
                flex-direction: row;
                right: 10px;
                bottom: 100px;
                top: auto;
            }

            .performance-info {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="game-hud">
            <div class="hud-section">
                <div class="stat">
                    <div class="stat-icon">üí£</div>
                    <div class="stat-value" id="mineCount">480</div>
                </div>
            </div>

            <div class="hud-section">
                <div class="controls">
                    <button class="btn-primary" onclick="resetGame()">üîÑ Restart</button>
                    <button class="btn-warning" id="flagModeBtn" onclick="toggleFlagMode()">üö© Flag Mode</button>
                    <button class="btn-success" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
                    <button class="btn-secondary" id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
                </div>
            </div>

            <div class="hud-section">
                <div class="stat">
                    <div class="stat-icon">‚è∞</div>
                    <div class="stat-value" id="timer">0</div>
                </div>
            </div>
        </div>

        <div class="difficulty-selector">
            <button class="difficulty-btn btn-secondary" data-difficulty="beginner">Beginner<br>9√ó9√ó9</button>
            <button class="difficulty-btn btn-secondary" data-difficulty="intermediate">Intermediate<br>16√ó16√ó16</button>
            <button class="difficulty-btn btn-secondary active" data-difficulty="expert">Expert<br>48√ó48√ó1</button>
            <button class="difficulty-btn btn-secondary" data-difficulty="custom">Custom<br>Settings</button>
        </div>

        <div class="camera-controls">
            <button class="camera-btn btn-secondary" onclick="resetCamera()">üì∑ Reset View</button>
            <button class="camera-btn btn-secondary" onclick="toggleAutoRotate()" id="autoRotateBtn">üîÑ Auto Rotate</button>
            <button class="camera-btn btn-secondary" onclick="switchView()">üëÅÔ∏è Switch View</button>
            <button class="camera-btn btn-secondary" onclick="toggleWireframe()" id="wireframeBtn">üî≤ Wireframe</button>
        </div>

        <div class="settings-panel">
            <h4>Graphics</h4>
            <div class="setting-item">
                <span>Effects:</span>
                <input type="range" id="effectsSlider" min="0" max="2" value="2" onchange="updateGraphics()">
            </div>
            <div class="setting-item">
                <span>Grid:</span>
                <input type="checkbox" id="gridToggle" checked onchange="toggleGrid()">
            </div>
            <div class="setting-item">
                <span>Shadows:</span>
                <input type="checkbox" id="shadowToggle" checked onchange="toggleShadows()">
            </div>
        </div>

        <div class="instructions">
            <h3>3D Controls</h3>
            <ul>
                <li>Mouse: Rotate camera</li>
                <li>Scroll: Zoom in/out</li>
                <li>Click: Reveal/Flag cell</li>
                <li>Right-click: Quick flag</li>
                <li>WASD: Move camera</li>
                <li>Space: Toggle flag mode</li>
                <li>P: Pause game</li>
                <li>R: Restart</li>
            </ul>
            <h3>Game Rules</h3>
            <ul>
                <li>Clear all non-mine cells</li>
                <li>Numbers show adjacent mines</li>
                <li>Flag suspected mines</li>
                <li>First click is always safe</li>
                <li>Middle-click: Auto-reveal</li>
            </ul>
        </div>

        <div class="performance-info" id="performanceInfo">
            FPS: 60<br>
            Cells: 0<br>
            Draw calls: 0
        </div>

        <div class="game-info">
            <span id="gameMode">Click to Reveal</span>
            <span id="coordinates">Position: 0, 0, 0</span>
            <span id="progress">Progress: 0%</span>
            <div id="gameStatus" class="status-indicator">Playing</div>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-title" id="gameOverTitle">üéâ</div>
            <div class="game-over-message" id="gameOverMessage">Congratulations!</div>
            <div class="game-over-stats" id="gameOverStats"></div>
            <div class="controls">
                <button class="btn-primary" onclick="resetGame(); hideGameOver()">New Game</button>
                <button class="btn-secondary" onclick="hideGameOver()">Continue</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class Minesweeper3D {
            constructor() {
                this.difficulties = {
                    beginner: { x: 9, y: 9, z: 9, mines: 80 },
                    intermediate: { x: 16, y: 16, z: 16, mines: 400 },
                    expert: { x: 48, y: 48, z: 1, mines: 480 },
                    custom: { x: 20, y: 20, z: 5, mines: 200 }
                };
                
                this.currentDifficulty = 'expert';
                this.grid = [];
                this.gameState = 'playing';
                this.isPaused = false;
                this.flagMode = false;
                this.firstClick = true;
                this.timer = 0;
                this.timerInterval = null;
                this.mineCount = 0;
                this.autoRotate = false;
                this.wireframe = false;
                this.showGrid = true;
                this.effectsLevel = 2;
                this.enableShadows = true;
                
                // Performance tracking
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 60;
                
                this.initThree();
                this.initializeGame();
                this.setupEventListeners();
                this.animate();
            }

            initThree() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f0f23);
                
                // Fog for depth perception
                if (this.effectsLevel >= 1) {
                    this.scene.fog = new THREE.Fog(0x0f0f23, 10, 100);
                }
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(30, 30, 30);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('gameCanvas'),
                    antialias: this.effectsLevel >= 2,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = this.enableShadows;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                
                // Lighting
                this.setupLighting();
                
                // Controls setup
                this.setupControls();
                
                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredCell = null;
                this.lastHoveredPosition = null;
                
                // Materials with improved shading
                this.setupMaterials();
                
                // Grid helper
                this.gridHelper = null;
                this.createGridHelper();
            }

            setupLighting() {
                // Remove existing lights
                this.scene.children = this.scene.children.filter(child => !(child instanceof THREE.Light));
                
                const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                
                if (this.enableShadows) {
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 1024;
                    directionalLight.shadow.mapSize.height = 1024;
                    directionalLight.shadow.camera.near = 0.5;
                    directionalLight.shadow.camera.far = 200;
                    directionalLight.shadow.camera.left = -50;
                    directionalLight.shadow.camera.right = 50;
                    directionalLight.shadow.camera.top = 50;
                    directionalLight.shadow.camera.bottom = -50;
                }
                
                this.scene.add(directionalLight);
                
                // Additional lighting for better visibility
                const pointLight = new THREE.PointLight(0x4080ff, 0.3, 100);
                pointLight.position.set(-30, 30, -30);
                this.scene.add(pointLight);
            }

            setupMaterials() {
                this.materials = {
                    hidden: new THREE.MeshPhongMaterial({ 
                        color: 0x666666,
                        shininess: 30,
                        transparent: false
                    }),
                    revealed: new THREE.MeshPhongMaterial({ 
                        color: 0xeeeeee,
                        shininess: 10
                    }),
                    flagged: new THREE.MeshPhongMaterial({ 
                        color: 0xff4444,
                        shininess: 50,
                        emissive: 0x220000,
                        emissiveIntensity: 0.1
                    }),
                    mine: new THREE.MeshPhongMaterial({ 
                        color: 0x330000,
                        shininess: 20,
                        emissive: 0x440000,
                        emissiveIntensity: 0.3
                    }),
                    hover: new THREE.MeshPhongMaterial({ 
                        color: 0x88aaff,
                        shininess: 100,
                        emissive: 0x002244,
                        emissiveIntensity: 0.2
                    }),
                    explosion: new THREE.MeshPhongMaterial({
                        color: 0xff6600,
                        emissive: 0xff2200,
                        emissiveIntensity: 0.5
                    })
                };
                
                // Enhanced number materials with better colors and effects
                this.numberMaterials = [
                    null, // 0
                    new THREE.MeshPhongMaterial({ color: 0x2266ff, shininess: 20 }), // 1 - blue
                    new THREE.MeshPhongMaterial({ color: 0x22aa22, shininess: 20 }), // 2 - green
                    new THREE.MeshPhongMaterial({ color: 0xff2222, shininess: 20 }), // 3 - red
                    new THREE.MeshPhongMaterial({ color: 0x8822aa, shininess: 20 }), // 4 - purple
                    new THREE.MeshPhongMaterial({ color: 0xaa2222, shininess: 20 }), // 5 - maroon
                    new THREE.MeshPhongMaterial({ color: 0x22aaaa, shininess: 20 }), // 6 - teal
                    new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 5 }),  // 7 - black
                    new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 10 })  // 8 - gray
                ];
            }

            createGridHelper() {
                if (this.gridHelper) {
                    this.scene.remove(this.gridHelper);
                }
                
                if (!this.showGrid) return;
                
                const config = this.difficulties[this.currentDifficulty];
                const size = Math.max(config.x, config.y, config.z);
                this.gridHelper = new THREE.GridHelper(size * 2, size, 0x444444, 0x222222);
                this.gridHelper.position.y = -config.y / 2;
                this.scene.add(this.gridHelper);
            }

            setupControls() {
                this.isMouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                this.cameraDistance = 50;
                this.cameraTheta = 0;
                this.cameraPhi = Math.PI / 4;
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                
                this.keys = {
                    w: false, a: false, s: false, d: false,
                    shift: false, ctrl: false
                };
            }

            initializeGame() {
                const config = this.difficulties[this.currentDifficulty];
                this.sizeX = config.x;
                this.sizeY = config.y;
                this.sizeZ = config.z;
                this.totalMines = config.mines;
                this.mineCount = this.totalMines;
                this.gameState = 'playing';
                this.isPaused = false;
                this.firstClick = true;
                this.timer = 0;
                
                this.createGrid();
                this.renderGrid3D();
                this.createGridHelper();
                this.updateUI();
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                this.resetCamera();
            }

            createGrid() {
                this.grid = [];
                for (let x = 0; x < this.sizeX; x++) {
                    this.grid[x] = [];
                    for (let y = 0; y < this.sizeY; y++) {
                        this.grid[x][y] = [];
                        for (let z = 0; z < this.sizeZ; z++) {
                            this.grid[x][y][z] = {
                                isMine: false,
                                isRevealed: false,
                                isFlagged: false,
                                adjacentMines: 0,
                                mesh: null,
                                position: { x, y, z },
                                animationPhase: 0
                            };
                        }
                    }
                }
            }

            placeMines(excludeX, excludeY, excludeZ) {
                // Create larger exclusion zone for better first-click experience
                const excludeZone = new Set();
                const radius = Math.max(1, Math.min(3, Math.floor(Math.min(this.sizeX, this.sizeY, this.sizeZ) / 10)));
                
                for (let x = Math.max(0, excludeX - radius); x <= Math.min(this.sizeX - 1, excludeX + radius); x++) {
                    for (let y = Math.max(0, excludeY - radius); y <= Math.min(this.sizeY - 1, excludeY + radius); y++) {
                        for (let z = Math.max(0, excludeZ - radius); z <= Math.min(this.sizeZ - 1, excludeZ + radius); z++) {
                            excludeZone.add(`${x},${y},${z}`);
                        }
                    }
                }
                
                let minesPlaced = 0;
                const maxAttempts = this.sizeX * this.sizeY * this.sizeZ * 3;
                let attempts = 0;
                
                while (minesPlaced < this.totalMines && attempts < maxAttempts) {
                    const x = Math.floor(Math.random() * this.sizeX);
                    const y = Math.floor(Math.random() * this.sizeY);
                    const z = Math.floor(Math.random() * this.sizeZ);
                    attempts++;
                    
                    if (excludeZone.has(`${x},${y},${z}`) || this.grid[x][y][z].isMine) {
                        continue;
                    }
                    
                    this.grid[x][y][z].isMine = true;
                    minesPlaced++;
                }
                
                // Calculate adjacent mine counts
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            if (!this.grid[x][y][z].isMine) {
                                this.grid[x][y][z].adjacentMines = this.countAdjacentMines(x, y, z);
                            }
                        }
                    }
                }
            }

            countAdjacentMines(x, y, z) {
                let count = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (dx === 0 && dy === 0 && dz === 0) continue;
                            
                            const nx = x + dx;
                            const ny = y + dy;
                            const nz = z + dz;
                            
                            if (nx >= 0 && nx < this.sizeX && 
                                ny >= 0 && ny < this.sizeY && 
                                nz >= 0 && nz < this.sizeZ) {
                                if (this.grid[nx][ny][nz].isMine) {
                                    count++;
                                }
                            }
                        }
                    }
                }
                return count;
            }

            renderGrid3D() {
                // Clear existing meshes
                const cellsToRemove = [];
                this.scene.traverse((child) => {
                    if (child.userData.isCell) {
                        cellsToRemove.push(child);
                    }
                });
                cellsToRemove.forEach(cell => this.scene.remove(cell));
                
                // Create new meshes with optimized geometry
                const geometries = {
                    normal: new THREE.BoxGeometry(0.8, 0.8, 0.8),
                    rounded: new THREE.BoxGeometry(0.8, 0.8, 0.8, 2, 2, 2)
                };
                
                const geometry = this.effectsLevel >= 2 ? geometries.rounded : geometries.normal;
                const spacing = 1;
                
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            const cell = this.grid[x][y][z];
                            let material = this.materials.hidden;
                            
                            if (cell.isFlagged) {
                                material = this.materials.flagged;
                            } else if (cell.isRevealed) {
                                if (cell.isMine) {
                                    material = this.materials.mine;
                                } else if (cell.adjacentMines > 0) {
                                    material = this.numberMaterials[cell.adjacentMines];
                                } else {
                                    material = this.materials.revealed;
                                }
                            }
                            
                            // Apply wireframe if enabled
                            if (this.wireframe) {
                                material = material.clone();
                                material.wireframe = true;
                            }
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(
                                (x - this.sizeX/2) * spacing,
                                (y - this.sizeY/2) * spacing,
                                (z - this.sizeZ/2) * spacing
                            );
                            mesh.userData = {
                                isCell: true,
                                x: x,
                                y: y,
                                z: z,
                                cell: cell
                            };
                            
                            if (this.enableShadows) {
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                            }
                            
                            this.scene.add(mesh);
                            cell.mesh = mesh;
                        }
                    }
                }
            }

            handleCellClick(x, y, z, isMiddleClick = false) {
                if (this.gameState !== 'playing' || this.isPaused) return;
                
                const cell = this.grid[x][y][z];
                
                if (isMiddleClick) {
                    // Middle click: Auto-reveal adjacent cells if flags match mine count
                    if (cell.isRevealed && cell.adjacentMines > 0) {
                        this.autoRevealAdjacent(x, y, z);
                    }
                    return;
                }
                
                if (cell.isFlagged && !this.flagMode) return;
                
                if (this.flagMode) {
                    this.toggleFlag(x, y, z);
                } else {
                    this.revealCell(x, y, z);
                }
            }

            autoRevealAdjacent(x, y, z) {
                const cell = this.grid[x][y][z];
                let flaggedCount = 0;
                const adjacentCells = [];
                
                // Count flagged adjacent cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (dx === 0 && dy === 0 && dz === 0) continue;
                            
                            const nx = x + dx, ny = y + dy, nz = z + dz;
                            if (nx >= 0 && nx < this.sizeX && ny >= 0 && ny < this.sizeY && nz >= 0 && nz < this.sizeZ) {
                                const adjCell = this.grid[nx][ny][nz];
                                if (adjCell.isFlagged) flaggedCount++;
                                else if (!adjCell.isRevealed) adjacentCells.push({ x: nx, y: ny, z: nz });
                            }
                        }
                    }
                }
                
                // If flagged count matches mine count, reveal all unflagged adjacent cells
                if (flaggedCount === cell.adjacentMines) {
                    adjacentCells.forEach(({x, y, z}) => this.revealCell(x, y, z));
                }
            }

            revealCell(x, y, z) {
                const cell = this.grid[x][y][z];
                
                if (cell.isRevealed || cell.isFlagged) return;
                
                if (this.firstClick) {
                    this.placeMines(x, y, z);
                    this.firstClick = false;
                    this.startTimer();
                }
                
                cell.isRevealed = true;
                this.animateReveal(cell);
                
                if (cell.isMine) {
                    this.gameState = 'lost';
                    this.revealAllMines();
                    this.endGame();
                } else {
                    if (cell.adjacentMines === 0) {
                        this.revealAdjacentCells(x, y, z);
                    }
                    this.checkWinCondition();
                }
                
                this.renderGrid3D();
                this.updateUI();
            }

            animateReveal(cell) {
                if (!cell.mesh || this.effectsLevel < 1) return;
                
                const originalScale = cell.mesh.scale.clone();
                cell.mesh.scale.set(0.1, 0.1, 0.1);
                
                const animate = () => {
                    cell.mesh.scale.lerp(originalScale, 0.3);
                    if (cell.mesh.scale.length() < originalScale.length() * 0.95) {
                        requestAnimationFrame(animate);
                    } else {
                        cell.mesh.scale.copy(originalScale);
                    }
                };
                animate();
            }

            revealAdjacentCells(x, y, z) {
                const stack = [{x, y, z}];
                const processed = new Set();
                
                while (stack.length > 0) {
                    const {x: cx, y: cy, z: cz} = stack.pop();
                    const key = `${cx},${cy},${cz}`;
                    
                    if (processed.has(key)) continue;
                    processed.add(key);
                    
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                if (dx === 0 && dy === 0 && dz === 0) continue;
                                
                                const nx = cx + dx, ny = cy + dy, nz = cz + dz;
                                if (nx >= 0 && nx < this.sizeX && ny >= 0 && ny < this.sizeY && nz >= 0 && nz < this.sizeZ) {
                                    const adjCell = this.grid[nx][ny][nz];
                                    if (!adjCell.isRevealed && !adjCell.isFlagged && !adjCell.isMine) {
                                        adjCell.isRevealed = true;
                                        this.animateReveal(adjCell);
                                        if (adjCell.adjacentMines === 0) {
                                            stack.push({x: nx, y: ny, z: nz});
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            toggleFlag(x, y, z) {
                const cell = this.grid[x][y][z];
                
                if (cell.isRevealed) return;
                
                cell.isFlagged = !cell.isFlagged;
                this.mineCount += cell.isFlagged ? -1 : 1;
                
                // Flag animation
                if (cell.mesh && this.effectsLevel >= 1) {
                    const targetY = cell.isFlagged ? 0.3 : 0;
                    const animate = () => {
                        const currentY = cell.mesh.position.y - ((cell.position.y - this.sizeY/2));
                        const newY = THREE.MathUtils.lerp(currentY, targetY, 0.2);
                        cell.mesh.position.y = (cell.position.y - this.sizeY/2) + newY;
                        
                        if (Math.abs(newY - targetY) > 0.01) {
                            requestAnimationFrame(animate);
                        }
                    };
                    animate();
                }
                
                this.renderGrid3D();
                this.updateUI();
            }

            revealAllMines() {
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            const cell = this.grid[x][y][z];
                            if (cell.isMine) {
                                cell.isRevealed = true;
                                if (cell.mesh && this.effectsLevel >= 2) {
                                    // Explosion effect
                                    cell.mesh.material = this.materials.explosion;
                                }
                            }
                        }
                    }
                }
            }

            checkWinCondition() {
                let revealedSafeCells = 0;
                const totalSafeCells = this.sizeX * this.sizeY * this.sizeZ - this.totalMines;
                
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            const cell = this.grid[x][y][z];
                            if (cell.isRevealed && !cell.isMine) {
                                revealedSafeCells++;
                            }
                        }
                    }
                }
                
                if (revealedSafeCells === totalSafeCells) {
                    this.gameState = 'won';
                    this.endGame();
                }
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    if (!this.isPaused) {
                        this.timer++;
                        this.updateUI();
                    }
                }, 1000);
            }

            endGame() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                setTimeout(() => {
                    this.showGameOver();
                }, 500);
            }

            showGameOver() {
                const overlay = document.getElementById('gameOverOverlay');
                const title = document.getElementById('gameOverTitle');
                const message = document.getElementById('gameOverMessage');
                const stats = document.getElementById('gameOverStats');
                
                const revealedCells = this.countRevealedCells();
                const totalSafeCells = this.sizeX * this.sizeY * this.sizeZ - this.totalMines;
                const progressPercent = Math.round((revealedCells / totalSafeCells) * 100);
                
                if (this.gameState === 'won') {
                    title.textContent = 'üéâ';
                    message.textContent = `Congratulations! You won!`;
                    stats.innerHTML = `
                        <div style="margin: 20px 0; font-size: 14px; color: #ccc;">
                            <div>‚è∞ Time: ${this.formatTime(this.timer)}</div>
                            <div>üí£ Mines: ${this.totalMines}</div>
                            <div>üéØ Accuracy: 100%</div>
                            <div>üì¶ Grid: ${this.sizeX}√ó${this.sizeY}√ó${this.sizeZ}</div>
                        </div>
                    `;
                } else {
                    title.textContent = 'üí£';
                    message.textContent = 'Game Over!';
                    stats.innerHTML = `
                        <div style="margin: 20px 0; font-size: 14px; color: #ccc;">
                            <div>‚è∞ Time: ${this.formatTime(this.timer)}</div>
                            <div>üìä Progress: ${progressPercent}%</div>
                            <div>üí£ Mines: ${this.totalMines}</div>
                            <div>üì¶ Grid: ${this.sizeX}√ó${this.sizeY}√ó${this.sizeZ}</div>
                        </div>
                    `;
                }
                
                overlay.style.display = 'flex';
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            countRevealedCells() {
                let count = 0;
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            if (this.grid[x][y][z].isRevealed && !this.grid[x][y][z].isMine) {
                                count++;
                            }
                        }
                    }
                }
                return count;
            }

            updateUI() {
                document.getElementById('mineCount').textContent = this.mineCount;
                document.getElementById('timer').textContent = this.formatTime(this.timer);
                document.getElementById('gameMode').textContent = this.flagMode ? 'Flag Mode ON' : 'Click to Reveal';
                
                // Progress indicator
                const revealedCells = this.countRevealedCells();
                const totalSafeCells = this.sizeX * this.sizeY * this.sizeZ - this.totalMines;
                const progressPercent = Math.round((revealedCells / totalSafeCells) * 100);
                document.getElementById('progress').textContent = `Progress: ${progressPercent}%`;
                
                const statusEl = document.getElementById('gameStatus');
                statusEl.className = 'status-indicator';
                
                switch (this.gameState) {
                    case 'won':
                        statusEl.textContent = 'Won! üéâ';
                        statusEl.style.background = 'linear-gradient(45deg, #ffc107, #d39e00)';
                        break;
                    case 'lost':
                        statusEl.textContent = 'Lost üí£';
                        statusEl.style.background = 'linear-gradient(45deg, #dc3545, #a71e2a)';
                        break;
                    default:
                        statusEl.textContent = this.isPaused ? 'Paused ‚è∏Ô∏è' : 'Playing';
                        statusEl.style.background = this.isPaused ? 
                            'linear-gradient(45deg, #6c757d, #495057)' : 
                            'linear-gradient(45deg, #28a745, #1e7e34)';
                }
                
                const flagBtn = document.getElementById('flagModeBtn');
                flagBtn.className = this.flagMode ? 'btn-danger' : 'btn-warning';
                flagBtn.textContent = this.flagMode ? 'üö© Flag ON' : 'üö© Flag OFF';
                
                const pauseBtn = document.getElementById('pauseBtn');
                pauseBtn.textContent = this.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
                
                const autoRotateBtn = document.getElementById('autoRotateBtn');
                autoRotateBtn.className = this.autoRotate ? 'camera-btn btn-success' : 'camera-btn btn-secondary';
                
                const wireframeBtn = document.getElementById('wireframeBtn');
                wireframeBtn.className = this.wireframe ? 'camera-btn btn-warning' : 'camera-btn btn-secondary';
            }

            setupEventListeners() {
                const canvas = document.getElementById('gameCanvas');
                
                // Mouse events with improved handling
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                canvas.addEventListener('wheel', (e) => this.onMouseWheel(e), { passive: false });
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Keyboard events
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentDifficulty = e.target.dataset.difficulty;
                        this.initializeGame();
                    });
                });

                // Settings
                document.getElementById('effectsSlider').addEventListener('input', (e) => {
                    this.effectsLevel = parseInt(e.target.value);
                    this.updateGraphics();
                });
            }

            onMouseDown(event) {
                event.preventDefault();
                
                if (event.button === 0) { // Left click
                    this.isMouseDown = true;
                    this.mouseX = event.clientX;
                    this.mouseY = event.clientY;
                    this.checkCellClick(event);
                } else if (event.button === 1) { // Middle click
                    event.preventDefault();
                    this.checkCellClick(event, false, true);
                } else if (event.button === 2) { // Right click
                    this.checkCellClick(event, true);
                }
            }

            onMouseMove(event) {
                if (this.isMouseDown && !this.isPaused) {
                    const deltaX = event.clientX - this.mouseX;
                    const deltaY = event.clientY - this.mouseY;
                    
                    const sensitivity = this.keys.shift ? 0.003 : 0.01;
                    
                    this.cameraTheta += deltaX * sensitivity;
                    this.cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, this.cameraPhi + deltaY * sensitivity));
                    
                    this.mouseX = event.clientX;
                    this.mouseY = event.clientY;
                }
                
                this.updateHover(event);
            }

            onMouseUp(event) {
                this.isMouseDown = false;
            }

            onMouseWheel(event) {
                event.preventDefault();
                if (this.isPaused) return;
                
                const zoomSpeed = this.keys.shift ? 0.5 : 2.0;
                this.cameraDistance *= (1 + event.deltaY * 0.001 * zoomSpeed);
                this.cameraDistance = Math.max(3, Math.min(300, this.cameraDistance));
            }

            checkCellClick(event, isRightClick = false, isMiddleClick = false) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.scene.children.filter(obj => obj.userData.isCell));
                
                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    const { x, y, z } = mesh.userData;
                    
                    if (isRightClick) {
                        this.toggleFlag(x, y, z);
                    } else {
                        this.handleCellClick(x, y, z, isMiddleClick);
                    }
                    
                    document.getElementById('coordinates').textContent = `Position: ${x}, ${y}, ${z}`;
                }
            }

            updateHover(event) {
                if (this.isPaused) return;
                
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.scene.children.filter(obj => obj.userData.isCell));
                
                // Reset previous hover
                if (this.hoveredCell && this.hoveredCell !== (intersects.length > 0 ? intersects[0].object : null)) {
                    this.resetCellMaterial(this.hoveredCell);
                }
                
                // Set new hover
                if (intersects.length > 0 && !intersects[0].object.userData.cell.isRevealed) {
                    this.hoveredCell = intersects[0].object;
                    this.hoveredCell.material = this.wireframe ? 
                        Object.assign(this.materials.hover.clone(), { wireframe: true }) : 
                        this.materials.hover;
                    
                    const { x, y, z } = this.hoveredCell.userData;
                    document.getElementById('coordinates').textContent = `Position: ${x}, ${y}, ${z}`;
                    
                    // Show adjacent mine count for revealed cells
                    const cell = this.grid[x][y][z];
                    if (cell.isRevealed && cell.adjacentMines > 0) {
                        // Could add tooltip or info display here
                    }
                } else {
                    this.hoveredCell = null;
                }
            }

            resetCellMaterial(mesh) {
                const cell = mesh.userData.cell;
                let material = this.materials.hidden;
                
                if (cell.isFlagged) {
                    material = this.materials.flagged;
                } else if (cell.isRevealed) {
                    if (cell.isMine) {
                        material = this.materials.mine;
                    } else if (cell.adjacentMines > 0) {
                        material = this.numberMaterials[cell.adjacentMines];
                    } else {
                        material = this.materials.revealed;
                    }
                }
                
                mesh.material = this.wireframe ? 
                    Object.assign(material.clone(), { wireframe: true }) : 
                    material;
            }

            onKeyDown(event) {
                switch (event.key.toLowerCase()) {
                    case 'w': this.keys.w = true; break;
                    case 'a': this.keys.a = true; break;
                    case 's': this.keys.s = true; break;
                    case 'd': this.keys.d = true; break;
                    case 'shift': this.keys.shift = true; break;
                    case 'control': this.keys.ctrl = true; break;
                    case ' ':
                        event.preventDefault();
                        this.toggleFlagMode();
                        break;
                    case 'p':
                        event.preventDefault();
                        this.togglePause();
                        break;
                    case 'r':
                        if (this.keys.ctrl) {
                            event.preventDefault();
                            this.initializeGame();
                        }
                        break;
                    case 'f':
                        if (this.keys.ctrl) {
                            event.preventDefault();
                            this.toggleFullscreen();
                        }
                        break;
                    case 'g':
                        this.toggleGrid();
                        break;
                    case 'h':
                        this.toggleInstructions();
                        break;
                }
            }

            onKeyUp(event) {
                switch (event.key.toLowerCase()) {
                    case 'w': this.keys.w = false; break;
                    case 'a': this.keys.a = false; break;
                    case 's': this.keys.s = false; break;
                    case 'd': this.keys.d = false; break;
                    case 'shift': this.keys.shift = false; break;
                    case 'control': this.keys.ctrl = false; break;
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            updateCamera() {
                if (this.isPaused && !this.autoRotate) return;
                
                // Enhanced WASD movement
                const moveSpeed = this.keys.shift ? 1.0 : 0.5;
                const rotateSpeed = this.keys.shift ? 0.01 : 0.02;
                
                if (this.keys.w) this.cameraDistance = Math.max(3, this.cameraDistance - moveSpeed);
                if (this.keys.s) this.cameraDistance = Math.min(300, this.cameraDistance + moveSpeed);
                if (this.keys.a) this.cameraTheta -= rotateSpeed;
                if (this.keys.d) this.cameraTheta += rotateSpeed;
                
                // Auto rotate
                if (this.autoRotate) {
                    this.cameraTheta += 0.005;
                }
                
                // Smooth camera movement
                const targetX = this.cameraDistance * Math.sin(this.cameraPhi) * Math.cos(this.cameraTheta);
                const targetY = this.cameraDistance * Math.cos(this.cameraPhi);
                const targetZ = this.cameraDistance * Math.sin(this.cameraPhi) * Math.sin(this.cameraTheta);
                
                this.camera.position.x = THREE.MathUtils.lerp(this.camera.position.x, targetX, 0.1);
                this.camera.position.y = THREE.MathUtils.lerp(this.camera.position.y, targetY, 0.1);
                this.camera.position.z = THREE.MathUtils.lerp(this.camera.position.z, targetZ, 0.1);
                
                this.camera.lookAt(this.cameraTarget);
            }

            updatePerformance() {
                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = now;
                    
                    const totalCells = this.sizeX * this.sizeY * this.sizeZ;
                    document.getElementById('performanceInfo').innerHTML = `
                        FPS: ${this.fps}<br>
                        Cells: ${totalCells}<br>
                        Renderer: WebGL
                    `;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateCamera();
                this.updatePerformance();
                this.renderer.render(this.scene, this.camera);
            }

            // Public methods for UI controls
            toggleFlagMode() {
                this.flagMode = !this.flagMode;
                this.updateUI();
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                this.updateUI();
            }

            resetCamera() {
                const config = this.difficulties[this.currentDifficulty];
                const maxSize = Math.max(config.x, config.y, config.z);
                
                this.cameraDistance = maxSize * 1.5 + 20;
                this.cameraTheta = Math.PI / 4;
                this.cameraPhi = Math.PI / 3;
                this.autoRotate = false;
                this.cameraTarget.set(0, 0, 0);
            }

            toggleAutoRotate() {
                this.autoRotate = !this.autoRotate;
                this.updateUI();
            }

            switchView() {
                if (this.currentDifficulty === 'expert') {
                    // For 2D expert mode, switch between views
                    if (this.cameraPhi < 0.3) {
                        this.cameraPhi = Math.PI / 3;
                        this.cameraDistance = 60;
                    } else {
                        this.cameraPhi = 0.1;
                        this.cameraDistance = 35;
                    }
                } else {
                    // For 3D modes, cycle through preset views
                    const views = [
                        { phi: Math.PI / 4, theta: 0, distance: 50 },
                        { phi: Math.PI / 2, theta: 0, distance: 40 },
                        { phi: Math.PI / 6, theta: Math.PI / 4, distance: 60 }
                    ];
                    
                    // Find closest view and switch to next
                    let closestIndex = 0;
                    let closestDistance = Infinity;
                    
                    views.forEach((view, index) => {
                        const dist = Math.abs(view.phi - this.cameraPhi) + Math.abs(view.theta - this.cameraTheta);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestIndex = index;
                        }
                    });
                    
                    const nextView = views[(closestIndex + 1) % views.length];
                    this.cameraPhi = nextView.phi;
                    this.cameraTheta = nextView.theta;
                    this.cameraDistance = nextView.distance;
                }
            }

            toggleWireframe() {
                this.wireframe = !this.wireframe;
                this.renderGrid3D();
                this.updateUI();
            }

            toggleGrid() {
                this.showGrid = !this.showGrid;
                this.createGridHelper();
            }

            toggleShadows() {
                this.enableShadows = !this.enableShadows;
                this.renderer.shadowMap.enabled = this.enableShadows;
                this.setupLighting();
                this.renderGrid3D();
            }

            updateGraphics() {
                this.setupLighting();
                this.setupMaterials();
                if (this.effectsLevel >= 1) {
                    this.scene.fog = new THREE.Fog(0x0f0f23, 10, 100);
                } else {
                    this.scene.fog = null;
                }
                this.renderer.antialias = this.effectsLevel >= 2;
                this.renderGrid3D();
            }

            toggleInstructions() {
                const instructions = document.querySelector('.instructions');
                instructions.style.opacity = instructions.style.opacity === '0' ? '1' : '0';
            }
        }

        // Global functions
        let game = new Minesweeper3D();

        function resetGame() {
            game.initializeGame();
        }

        function toggleFlagMode() {
            game.toggleFlagMode();
        }

        function togglePause() {
            game.togglePause();
        }

        function hideGameOver() {
            document.getElementById('gameOverOverlay').style.display = 'none';
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen not supported');
                });
            } else {
                document.exitFullscreen();
            }
        }

        function resetCamera() {
            game.resetCamera();
        }

        function toggleAutoRotate() {
            game.toggleAutoRotate();
        }

        function switchView() {
            game.switchView();
        }

        function toggleWireframe() {
            game.toggleWireframe();
        }

        function toggleGrid() {
            game.toggleGrid();
            document.getElementById('gridToggle').checked = game.showGrid;
        }

        function toggleShadows() {
            game.toggleShadows();
            document.getElementById('shadowToggle').checked = game.enableShadows;
        }

        function updateGraphics() {
            const level = parseInt(document.getElementById('effectsSlider').value);
            game.effectsLevel = level;
            game.updateGraphics();
        }

        // Initialize settings based on game state
        window.addEventListener('load', () => {
            document.getElementById('effectsSlider').value = game.effectsLevel;
            document.getElementById('gridToggle').checked = game.showGrid;
            document.getElementById('shadowToggle').checked = game.enableShadows;
        });

        // Add some helpful keyboard shortcuts info
        console.log(`
üéÆ 3D Minesweeper Pro - Keyboard Shortcuts:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéØ Game Controls:
   Space     - Toggle flag mode
   P         - Pause/Resume game
   R         - Restart game
   Ctrl+R    - Quick restart
   Ctrl+F    - Toggle fullscreen

üì∑ Camera Controls:
   WASD      - Move camera
   Shift+Key - Fast movement/rotation
   Mouse     - Rotate view
   Scroll    - Zoom in/out

üé® Display Options:
   G         - Toggle grid helper
   H         - Toggle instructions

üñ±Ô∏è  Mouse Controls:
   Left Click    - Reveal cell
   Right Click   - Flag cell  
   Middle Click  - Auto-reveal adjacent (when numbers match flags)
   Shift+Mouse   - Precision camera control

Happy mining! üí£
        `);
    </script>
</body>
</html>

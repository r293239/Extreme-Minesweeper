<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üí£ 3D Minesweeper Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
        }

        .game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            pointer-events: auto;
        }

        .hud-section {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .menu-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            pointer-events: auto;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-primary { background: linear-gradient(45deg, #007bff, #0056b3); }
        .btn-success { background: linear-gradient(45deg, #28a745, #1e7e34); }
        .btn-danger { background: linear-gradient(45deg, #dc3545, #a71e2a); }
        .btn-warning { background: linear-gradient(45deg, #ffc107, #d39e00); }
        .btn-secondary { background: linear-gradient(45deg, #6c757d, #495057); }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            border-radius: 8px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            top: 100%;
            right: 0;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-content button {
            background: none;
            border: none;
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            font-size: 12px;
            cursor: pointer;
            border-radius: 0;
            transform: none;
            box-shadow: none;
        }

        .dropdown-content button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .dropdown-content button:first-child {
            border-radius: 8px 8px 0 0;
        }

        .dropdown-content button:last-child {
            border-radius: 0 0 8px 8px;
        }

        .difficulty-selector {
            position: absolute;
            top: 100px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }

        .difficulty-btn {
            padding: 8px 16px;
            font-size: 12px;
            min-width: 120px;
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, #28a745, #1e7e34);
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.4);
        }

        .game-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            font-size: 12px;
            color: #ccc;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            cursor: crosshair;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .game-over-content {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .game-over-title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        @media (max-width: 768px) {
            .game-hud {
                flex-direction: column;
                align-items: stretch;
            }
            
            .difficulty-selector {
                position: relative;
                top: auto;
                left: auto;
                flex-direction: row;
                gap: 5px;
                overflow-x: auto;
                padding: 10px;
            }

            .dropdown-content {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="game-hud">
            <div class="hud-section">
                <div class="stat">
                    <div class="stat-icon">üí£</div>
                    <div class="stat-value" id="mineCount">480</div>
                </div>
            </div>

            <div class="hud-section">
                <div class="menu-section">
                    <button class="btn-primary" onclick="game.resetGame()">üîÑ New Game</button>
                    <button class="btn-warning" id="flagModeBtn" onclick="game.toggleFlagMode()">üö© Flag Mode</button>
                    
                    <div class="dropdown">
                        <button class="btn-secondary">‚öôÔ∏è Settings</button>
                        <div class="dropdown-content">
                            <button onclick="game.toggleGrid()">üìè Toggle Grid</button>
                            <button onclick="game.toggleAutoRotate()">üîÑ Auto Rotate</button>
                            <button onclick="game.resetCamera()">üì∑ Reset Camera</button>
                            <button onclick="game.switchView()">üëÅÔ∏è Switch View</button>
                            <button onclick="game.toggleFullscreen()">‚õ∂ Fullscreen</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="hud-section">
                <div class="stat">
                    <div class="stat-icon">‚è∞</div>
                    <div class="stat-value" id="timer">0</div>
                </div>
            </div>
        </div>

        <div class="difficulty-selector">
            <button class="difficulty-btn btn-secondary" data-difficulty="beginner">Easy<br>9√ó9√ó9</button>
            <button class="difficulty-btn btn-secondary" data-difficulty="intermediate">Medium<br>16√ó16√ó16</button>
            <button class="difficulty-btn btn-secondary active" data-difficulty="expert">Hard<br>48√ó48√ó1</button>
        </div>

        <div class="game-info">
            <span id="gameMode">Click to Reveal</span>
            <span id="coordinates">Position: 0, 0, 0</span>
            <span id="progress">Progress: 0%</span>
            <div id="gameStatus" class="status-indicator">Playing</div>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-title" id="gameOverTitle">üéâ</div>
            <div class="game-over-message" id="gameOverMessage">Congratulations!</div>
            <div class="game-over-stats" id="gameOverStats"></div>
            <div class="controls">
                <button class="btn-primary" onclick="game.resetGame(); game.hideGameOver()">New Game</button>
                <button class="btn-secondary" onclick="game.hideGameOver()">Continue</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class Minesweeper3D {
            constructor() {
                this.difficulties = {
                    beginner: { x: 9, y: 9, z: 9, mines: 80 },
                    intermediate: { x: 16, y: 16, z: 16, mines: 400 },
                    expert: { x: 48, y: 48, z: 1, mines: 480 }
                };
                
                this.currentDifficulty = 'expert';
                this.grid = [];
                this.gameState = 'playing';
                this.flagMode = false;
                this.firstClick = true;
                this.timer = 0;
                this.timerInterval = null;
                this.mineCount = 0;
                this.autoRotate = false;
                this.showGrid = true;
                this.isOrthographic = false;
                
                // Touch controls
                this.isTouchDevice = 'ontouchstart' in window;
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.touchStartTime = 0;
                this.isSwipe = false;
                this.longPressTimeout = null;
                this.isLongPress = false;
                
                // Two-finger panning
                this.twoFingerStart = { x: 0, y: 0 };
                this.isTwoFingerPan = false;
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.cameraPanSpeed = 0.02;
                this.cameraDistance = 50;
                
                // Container for all cubes
                this.cubeContainer = null;
                
                this.initThree();
                this.initializeGame();
                this.setupEventListeners();
                this.animate();
            }

            initThree() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f0f23);
                this.scene.fog = new THREE.Fog(0x0f0f23, 10, 100);
                
                // Create container for all cubes
                this.cubeContainer = new THREE.Group();
                this.scene.add(this.cubeContainer);
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(30, 30, 30);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);
                
                // Controls setup
                this.setupControls();
                
                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredCell = null;
                
                // Materials
                this.setupMaterials();
                
                // Grid helper
                this.gridHelper = null;
                this.createGridHelper();
            }

            setupMaterials() {
                this.materials = {
                    hidden: new THREE.MeshPhongMaterial({ color: 0x666666, shininess: 30 }),
                    revealed: new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 10 }),
                    flagged: new THREE.MeshPhongMaterial({ color: 0xff4444, shininess: 50, emissive: 0x220000, emissiveIntensity: 0.1 }),
                    mine: new THREE.MeshPhongMaterial({ color: 0x330000, shininess: 20, emissive: 0x440000, emissiveIntensity: 0.3 }),
                    hover: new THREE.MeshPhongMaterial({ color: 0x88aaff, shininess: 100, emissive: 0x002244, emissiveIntensity: 0.2 })
                };
                
                // Number materials with colors
                this.numberMaterials = [
                    null,
                    new THREE.MeshPhongMaterial({ color: 0x2266ff, shininess: 20 }),
                    new THREE.MeshPhongMaterial({ color: 0x22aa22, shininess: 20 }),
                    new THREE.MeshPhongMaterial({ color: 0xff2222, shininess: 20 }),
                    new THREE.MeshPhongMaterial({ color: 0x8822aa, shininess: 20 }),
                    new THREE.MeshPhongMaterial({ color: 0xaa2222, shininess: 20 }),
                    new THREE.MeshPhongMaterial({ color: 0x22aaaa, shininess: 20 }),
                    new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 5 }),
                    new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 10 })
                ];
            }

            setupControls() {
                this.isMouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                this.cameraTheta = 0;
                this.cameraPhi = Math.PI / 4;
                
                this.keys = { w: false, a: false, s: false, d: false };
            }

            createGridHelper() {
                if (this.gridHelper) {
                    this.scene.remove(this.gridHelper);
                }
                
                if (!this.showGrid) return;
                
                const config = this.difficulties[this.currentDifficulty];
                const size = Math.max(config.x, config.y, config.z);
                this.gridHelper = new THREE.GridHelper(size * 2, size, 0x444444, 0x222222);
                this.gridHelper.position.y = -config.y / 2;
                this.scene.add(this.gridHelper);
            }

            initializeGame() {
                const config = this.difficulties[this.currentDifficulty];
                this.sizeX = config.x;
                this.sizeY = config.y;
                this.sizeZ = config.z;
                this.totalMines = config.mines;
                this.mineCount = this.totalMines;
                this.gameState = 'playing';
                this.firstClick = true;
                this.timer = 0;
                
                // Reset cube container position
                this.cubeContainer.position.set(0, 0, 0);
                
                this.createGrid();
                this.renderGrid3D();
                this.createGridHelper();
                this.updateUI();
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                this.resetCamera();
            }

            createGrid() {
                this.grid = [];
                for (let x = 0; x < this.sizeX; x++) {
                    this.grid[x] = [];
                    for (let y = 0; y < this.sizeY; y++) {
                        this.grid[x][y] = [];
                        for (let z = 0; z < this.sizeZ; z++) {
                            this.grid[x][y][z] = {
                                isMine: false,
                                isRevealed: false,
                                isFlagged: false,
                                adjacentMines: 0,
                                mesh: null,
                                position: { x, y, z }
                            };
                        }
                    }
                }
            }

            renderGrid3D() {
                // Clear existing meshes from cube container
                while (this.cubeContainer.children.length > 0) {
                    this.cubeContainer.remove(this.cubeContainer.children[0]);
                }
                
                const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const spacing = 1;
                
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            const cell = this.grid[x][y][z];
                            let material = this.materials.hidden;
                            
                            if (cell.isFlagged) {
                                material = this.materials.flagged;
                            } else if (cell.isRevealed) {
                                if (cell.isMine) {
                                    material = this.materials.mine;
                                } else if (cell.adjacentMines > 0) {
                                    material = this.numberMaterials[cell.adjacentMines];
                                } else {
                                    material = this.materials.revealed;
                                }
                            }
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(
                                (x - this.sizeX/2) * spacing,
                                (y - this.sizeY/2) * spacing,
                                (z - this.sizeZ/2) * spacing
                            );
                            mesh.userData = { isCell: true, x, y, z, cell };
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            
                            this.cubeContainer.add(mesh);
                            cell.mesh = mesh;
                            
                            // Add engraved number for revealed cells
                            if (cell.isRevealed && !cell.isMine && cell.adjacentMines > 0) {
                                this.createEngravedNumber(cell, x, y, z);
                            }
                        }
                    }
                }
            }

            createEngravedNumber(cell, x, y, z) {
                // Create canvas for number texture
                const canvas = document.createElement('canvas');
                const size = 64;
                canvas.width = size;
                canvas.height = size;
                const context = canvas.getContext('2d');
                
                // Draw background
                context.fillStyle = '#f0f0f0';
                context.fillRect(0, 0, size, size);
                
                // Draw number
                const colors = ['', '#2266ff', '#22aa22', '#ff2222', '#8822aa', '#aa2222', '#22aaaa', '#222222', '#888888'];
                context.fillStyle = colors[cell.adjacentMines] || '#000000';
                context.font = 'bold 40px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(cell.adjacentMines.toString(), size/2, size/2);
                
                // Create texture and material
                const texture = new THREE.CanvasTexture(canvas);
                const numberMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                
                // Create plane geometry for the number
                const numberGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                
                // Position on cube face
                numberMesh.position.copy(cell.mesh.position);
                numberMesh.position.z += 0.41;
                numberMesh.userData = { isNumber: true, parentCell: { x, y, z } };
                
                this.cubeContainer.add(numberMesh);
            }

            placeMines(excludeX, excludeY, excludeZ) {
                // Create exclusion zone around first click
                const excludeZone = new Set();
                for (let x = Math.max(0, excludeX - 1); x <= Math.min(this.sizeX - 1, excludeX + 1); x++) {
                    for (let y = Math.max(0, excludeY - 1); y <= Math.min(this.sizeY - 1, excludeY + 1); y++) {
                        for (let z = Math.max(0, excludeZ - 1); z <= Math.min(this.sizeZ - 1, excludeZ + 1); z++) {
                            excludeZone.add(`${x},${y},${z}`);
                        }
                    }
                }
                
                let minesPlaced = 0;
                const maxAttempts = this.sizeX * this.sizeY * this.sizeZ * 3;
                let attempts = 0;
                
                while (minesPlaced < this.totalMines && attempts < maxAttempts) {
                    const x = Math.floor(Math.random() * this.sizeX);
                    const y = Math.floor(Math.random() * this.sizeY);
                    const z = Math.floor(Math.random() * this.sizeZ);
                    attempts++;
                    
                    if (excludeZone.has(`${x},${y},${z}`) || this.grid[x][y][z].isMine) {
                        continue;
                    }
                    
                    this.grid[x][y][z].isMine = true;
                    minesPlaced++;
                }
                
                // Calculate adjacent mine counts
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            if (!this.grid[x][y][z].isMine) {
                                this.grid[x][y][z].adjacentMines = this.countAdjacentMines(x, y, z);
                            }
                        }
                    }
                }
            }

            countAdjacentMines(x, y, z) {
                let count = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (dx === 0 && dy === 0 && dz === 0) continue;
                            
                            const nx = x + dx, ny = y + dy, nz = z + dz;
                            if (nx >= 0 && nx < this.sizeX && ny >= 0 && ny < this.sizeY && nz >= 0 && nz < this.sizeZ) {
                                if (this.grid[nx][ny][nz].isMine) count++;
                            }
                        }
                    }
                }
                return count;
            }

            handleCellClick(x, y, z, isMiddleClick = false) {
                if (this.gameState !== 'playing') return;
                
                const cell = this.grid[x][y][z];
                
                if (isMiddleClick && cell.isRevealed && cell.adjacentMines > 0) {
                    this.autoRevealAdjacent(x, y, z);
                    return;
                }
                
                if (cell.isFlagged && !this.flagMode) return;
                
                if (this.flagMode) {
                    this.toggleFlag(x, y, z);
                } else {
                    this.revealCell(x, y, z);
                }
            }

            autoRevealAdjacent(x, y, z) {
                const cell = this.grid[x][y][z];
                let flaggedCount = 0;
                const adjacentCells = [];
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (dx === 0 && dy === 0 && dz === 0) continue;
                            
                            const nx = x + dx, ny = y + dy, nz = z + dz;
                            if (nx >= 0 && nx < this.sizeX && ny >= 0 && ny < this.sizeY && nz >= 0 && nz < this.sizeZ) {
                                const adjCell = this.grid[nx][ny][nz];
                                if (adjCell.isFlagged) flaggedCount++;
                                else if (!adjCell.isRevealed) adjacentCells.push({ x: nx, y: ny, z: nz });
                            }
                        }
                    }
                }
                
                if (flaggedCount === cell.adjacentMines) {
                    adjacentCells.forEach(({x, y, z}) => this.revealCell(x, y, z));
                }
            }

            revealCell(x, y, z) {
                const cell = this.grid[x][y][z];
                if (cell.isRevealed || cell.isFlagged) return;
                
                if (this.firstClick) {
                    this.placeMines(x, y, z);
                    this.firstClick = false;
                    this.startTimer();
                }
                
                cell.isRevealed = true;
                
                if (cell.isMine) {
                    this.gameState = 'lost';
                    this.revealAllMines();
                    this.endGame();
                } else {
                    if (cell.adjacentMines === 0) {
                        this.revealAdjacentCells(x, y, z);
                    }
                    this.checkWinCondition();
                }
                
                this.renderGrid3D();
                this.updateUI();
            }

            revealAdjacentCells(x, y, z) {
                const stack = [{x, y, z}];
                const processed = new Set();
                
                while (stack.length > 0) {
                    const {x: cx, y: cy, z: cz} = stack.pop();
                    const key = `${cx},${cy},${cz}`;
                    if (processed.has(key)) continue;
                    processed.add(key);
                    
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                if (dx === 0 && dy === 0 && dz === 0) continue;
                                
                                const nx = cx + dx, ny = cy + dy, nz = cz + dz;
                                if (nx >= 0 && nx < this.sizeX && ny >= 0 && ny < this.sizeY && nz >= 0 && nz < this.sizeZ) {
                                    const adjCell = this.grid[nx][ny][nz];
                                    if (!adjCell.isRevealed && !adjCell.isFlagged && !adjCell.isMine) {
                                        adjCell.isRevealed = true;
                                        if (adjCell.adjacentMines === 0) {
                                            stack.push({x: nx, y: ny, z: nz});
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            toggleFlag(x, y, z) {
                const cell = this.grid[x][y][z];
                if (cell.isRevealed) return;
                
                cell.isFlagged = !cell.isFlagged;
                if (cell.isFlagged) {
                    this.mineCount--;
                } else {
                    this.mineCount++;
                }
                
                this.renderGrid3D();
                this.updateUI();
            }

            checkWinCondition() {
                let unrevealedSafeCells = 0;
                
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            const cell = this.grid[x][y][z];
                            if (!cell.isRevealed && !cell.isMine) {
                                unrevealedSafeCells++;
                            }
                        }
                    }
                }
                
                if (unrevealedSafeCells === 0) {
                    this.gameState = 'won';
                    this.endGame();
                }
            }

            revealAllMines() {
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            const cell = this.grid[x][y][z];
                            if (cell.isMine && !cell.isFlagged) {
                                cell.isRevealed = true;
                            }
                        }
                    }
                }
            }

            startTimer() {
                this.timer = 0;
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    document.getElementById('timer').textContent = this.timer;
                }, 1000);
            }

            endGame() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                if (this.gameState === 'won') {
                    this.showGameOver('üéâ You Win!', 'Congratulations! You found all the mines!');
                } else if (this.gameState === 'lost') {
                    this.showGameOver('üí• Game Over', 'You hit a mine! Try again.');
                }
                
                this.updateUI();
            }

            showGameOver(title, message) {
                document.getElementById('gameOverTitle').textContent = title;
                document.getElementById('gameOverMessage').textContent = message;
                document.getElementById('gameOverStats').innerHTML = `
                    <p>Time: ${this.timer} seconds</p>
                    <p>Difficulty: ${this.currentDifficulty}</p>
                `;
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }

            hideGameOver() {
                document.getElementById('gameOverOverlay').style.display = 'none';
            }

            updateUI() {
                document.getElementById('mineCount').textContent = this.mineCount;
                document.getElementById('timer').textContent = this.timer;
                document.getElementById('gameMode').textContent = this.flagMode ? 'Flag Mode' : 'Reveal Mode';
                document.getElementById('gameStatus').textContent = this.gameState === 'playing' ? 'Playing' : 
                    this.gameState === 'won' ? 'Victory!' : 'Game Over';
                
                // Calculate progress
                let revealedCells = 0;
                let totalSafeCells = 0;
                
                for (let x = 0; x < this.sizeX; x++) {
                    for (let y = 0; y < this.sizeY; y++) {
                        for (let z = 0; z < this.sizeZ; z++) {
                            if (!this.grid[x][y][z].isMine) {
                                totalSafeCells++;
                                if (this.grid[x][y][z].isRevealed) {
                                    revealedCells++;
                                }
                            }
                        }
                    }
                }
                
                const progress = totalSafeCells > 0 ? Math.round((revealedCells / totalSafeCells) * 100) : 0;
                document.getElementById('progress').textContent = `Progress: ${progress}%`;
                
                // Update flag mode button
                const flagModeBtn = document.getElementById('flagModeBtn');
                if (this.flagMode) {
                    flagModeBtn.style.background = 'linear-gradient(45deg, #dc3545, #a71e2a)';
                } else {
                    flagModeBtn.style.background = 'linear-gradient(45deg, #ffc107, #d39e00)';
                }
            }

            toggleFlagMode() {
                this.flagMode = !this.flagMode;
                this.updateUI();
            }

            resetGame() {
                this.initializeGame();
                this.hideGameOver();
            }

            toggleGrid() {
                this.showGrid = !this.showGrid;
                this.createGridHelper();
            }

            toggleAutoRotate() {
                this.autoRotate = !this.autoRotate;
            }

            resetCamera() {
                this.camera.position.set(30, 30, 30);
                this.camera.lookAt(0, 0, 0);
                this.cameraTarget.set(0, 0, 0);
                this.cameraDistance = 50;
                this.cameraTheta = 0;
                this.cameraPhi = Math.PI / 4;
                this.cubeContainer.position.set(0, 0, 0);
            }

            switchView() {
                this.isOrthographic = !this.isOrthographic;
                
                if (this.isOrthographic) {
                    const config = this.difficulties[this.currentDifficulty];
                    const aspect = window.innerWidth / window.innerHeight;
                    const size = Math.max(config.x, config.y, config.z) * 1.2;
                    
                    this.camera = new THREE.OrthographicCamera(
                        -size * aspect / 2, size * aspect / 2,
                        size / 2, -size / 2,
                        0.1, 1000
                    );
                    this.camera.position.set(0, 0, 50);
                    this.camera.lookAt(0, 0, 0);
                } else {
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.resetCamera();
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }

            // Two-finger panning function - WORKING VERSION
            handleTwoFingerPan(deltaX, deltaY) {
                // Move the cube container instead of individual cubes
                this.cubeContainer.position.x -= deltaX * this.cameraPanSpeed;
                this.cubeContainer.position.y += deltaY * this.cameraPanSpeed;
            }

            setupEventListeners() {
                // Mouse events
                document.getElementById('gameCanvas').addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    // Handle cell click
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.cubeContainer.children, true);
                    
                    for (let i = 0; i < intersects.length; i++) {
                        const object = intersects[i].object;
                        if (object.userData.isCell) {
                            const { x, y, z } = object.userData;
                            const isMiddleClick = e.button === 1;
                            this.handleCellClick(x, y, z, isMiddleClick);
                            break;
                        }
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                });
                
                document.addEventListener('mousemove', (e) => {
                    // Update mouse position for raycaster
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    // Camera rotation
                    if (this.isMouseDown) {
                        const deltaX = e.clientX - this.mouseX;
                        const deltaY = e.clientY - this.mouseY;
                        
                        this.cameraTheta += deltaX * 0.01;
                        this.cameraPhi += deltaY * 0.01;
                        this.cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, this.cameraPhi));
                        
                        this.updateCameraPosition();
                        
                        this.mouseX = e.clientX;
                        this.mouseY = e.clientY;
                    }
                    
                    // Update coordinates display
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.cubeContainer.children, true);
                    
                    let coordinates = 'Position: None';
                    for (let i = 0; i < intersects.length; i++) {
                        const object = intersects[i].object;
                        if (object.userData.isCell) {
                            const { x, y, z } = object.userData;
                            coordinates = `Position: ${x}, ${y}, ${z}`;
                            break;
                        }
                    }
                    document.getElementById('coordinates').textContent = coordinates;
                });
                
                // Mouse wheel for zoom
                document.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.cameraDistance += e.deltaY * 0.01;
                    this.cameraDistance = Math.max(10, Math.min(100, this.cameraDistance));
                    this.updateCameraPosition();
                });
                
                // Touch events for two-finger panning
                document.getElementById('gameCanvas').addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        // Two-finger touch detected - start panning
                        this.isTwoFingerPan = true;
                        this.twoFingerStart.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        this.twoFingerStart.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                        e.preventDefault();
                    } else if (e.touches.length === 1) {
                        // Single touch - prepare for cell interaction
                        const touch = e.touches[0];
                        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        
                        // Check if we're touching a cell
                        this.raycaster.setFromCamera(this.mouse, this.camera);
                        const intersects = this.raycaster.intersectObjects(this.cubeContainer.children, true);
                        
                        for (let i = 0; i < intersects.length; i++) {
                            const object = intersects[i].object;
                            if (object.userData.isCell) {
                                // Set up long press for flagging
                                this.longPressTimeout = setTimeout(() => {
                                    this.isLongPress = true;
                                    const { x, y, z } = object.userData;
                                    this.toggleFlag(x, y, z);
                                }, 500);
                                break;
                            }
                        }
                    }
                });
                
                document.getElementById('gameCanvas').addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && this.isTwoFingerPan) {
                        // Two-finger panning
                        const currentX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const currentY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                        
                        const deltaX = currentX - this.twoFingerStart.x;
                        const deltaY = currentY - this.twoFingerStart.y;
                        
                        this.handleTwoFingerPan(deltaX, deltaY);
                        
                        this.twoFingerStart.x = currentX;
                        this.twoFingerStart.y = currentY;
                        e.preventDefault();
                    } else if (e.touches.length === 1 && !this.isTwoFingerPan) {
                        // Single finger move - cancel long press if moving too much
                        if (this.longPressTimeout) {
                            clearTimeout(this.longPressTimeout);
                            this.longPressTimeout = null;
                        }
                        
                        // Update coordinates display
                        const touch = e.touches[0];
                        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        
                        this.raycaster.setFromCamera(this.mouse, this.camera);
                        const intersects = this.raycaster.intersectObjects(this.cubeContainer.children, true);
                        
                        let coordinates = 'Position: None';
                        for (let i = 0; i < intersects.length; i++) {
                            const object = intersects[i].object;
                            if (object.userData.isCell) {
                                const { x, y, z } = object.userData;
                                coordinates = `Position: ${x}, ${y}, ${z}`;
                                break;
                            }
                        }
                        document.getElementById('coordinates').textContent = coordinates;
                    }
                });
                
                document.getElementById('gameCanvas').addEventListener('touchend', (e) => {
                    if (this.isTwoFingerPan && e.touches.length < 2) {
                        this.isTwoFingerPan = false;
                    }
                    
                    if (this.longPressTimeout && !this.isLongPress) {
                        // Single tap - reveal cell
                        clearTimeout(this.longPressTimeout);
                        this.longPressTimeout = null;
                        
                        const touch = e.changedTouches[0];
                        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        
                        this.raycaster.setFromCamera(this.mouse, this.camera);
                        const intersects = this.raycaster.intersectObjects(this.cubeContainer.children, true);
                        
                        for (let i = 0; i < intersects.length; i++) {
                            const object = intersects[i].object;
                            if (object.userData.isCell) {
                                const { x, y, z } = object.userData;
                                this.revealCell(x, y, z);
                                break;
                            }
                        }
                    }
                    
                    this.isLongPress = false;
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.key in this.keys) {
                        this.keys[e.key] = true;
                    }
                    
                    // Space to toggle flag mode
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.toggleFlagMode();
                    }
                    
                    // R to reset game
                    if (e.code === 'KeyR') {
                        this.resetGame();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.key in this.keys) {
                        this.keys[e.key] = false;
                    }
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentDifficulty = btn.dataset.difficulty;
                        this.resetGame();
                    });
                });
            }

            updateCameraPosition() {
                if (!this.isOrthographic) {
                    this.camera.position.x = this.cameraDistance * Math.sin(this.cameraPhi) * Math.cos(this.cameraTheta);
                    this.camera.position.y = this.cameraDistance * Math.cos(this.cameraPhi);
                    this.camera.position.z = this.cameraDistance * Math.sin(this.cameraPhi) * Math.sin(this.cameraTheta);
                    this.camera.lookAt(this.cameraTarget);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Auto-rotate
                if (this.autoRotate) {
                    this.cameraTheta += 0.005;
                    this.updateCameraPosition();
                }
                
                // Keyboard camera movement
                if (this.keys.w) this.cameraPhi -= 0.02;
                if (this.keys.s) this.cameraPhi += 0.02;
                if (this.keys.a) this.cameraTheta -= 0.02;
                if (this.keys.d) this.cameraTheta += 0.02;
                
                this.cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, this.cameraPhi));
                
                if (this.keys.w || this.keys.s || this.keys.a || this.keys.d) {
                    this.updateCameraPosition();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the game when the page loads
        let game;
        window.addEventListener('DOMContentLoaded', () => {
            game = new Minesweeper3D();
        });
    </script>
</body>
</html>
